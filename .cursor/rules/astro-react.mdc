---
description: Rules for Astro and React files in PrawnikGPT
globs: *.astro,*.tsx,*.ts,*.jsx,*.js
alwaysApply: false
---

# Frontend Guidelines (Astro + React Islands)

## General Architecture

- **Use Astro components** (.astro) for static content and layout
- **Use React islands** (.tsx) for interactivity ONLY when needed
- **Minimize JavaScript:** Astro ships zero JS by default; keep it that way for static parts
- **Partial hydration:** Use `client:*` directives strategically

---

## Astro-Specific Guidelines

### When to Use Astro Components
- Layouts (BaseLayout, AppLayout)
- Static pages (landing page, legal texts)
- Headers, footers, navigation (no interactivity)
- Content-heavy sections (welcome message, example questions)

### Best Practices from 10x-rules
- **Use Astro components (.astro) for static content and layout** - Minimize JavaScript by default
- **Leverage View Transitions API** for smooth page transitions
- **Use content collections with type safety** for blog posts, documentation, etc.
- **Implement middleware** for request/response modification
- **Use image optimization** with the Astro Image integration
- **Leverage Server Endpoints** for API routes
- **Implement hybrid rendering** with server-side rendering where needed
- **Use Astro.cookies** for server-side cookie management
- **Leverage import.meta.env** for environment variables (with type safety via env.d.ts)

### Component Props
```astro
---
interface Props {
  title: string;
  showWelcome?: boolean;
}

const { title, showWelcome = false } = Astro.props;
---

<h1>{title}</h1>
{showWelcome && <WelcomeMessage />}
```

### Fetching Data in Astro
```astro
---
// Top-level await is supported
const response = await fetch('http://localhost:8000/api/data');
const data = await response.json();
---

<div>{data.title}</div>
```

### View Transitions API
```astro
---
// Enable smooth page transitions
import { ViewTransitions } from 'astro:transitions';
---

<head>
  <ViewTransitions />
</head>
```

---

## React Islands Guidelines

### When to Use React Components
- Forms (login, register, chat input)
- Interactive UI (rating buttons, delete confirmations)
- State management (chat messages, user menu)
- Real-time updates (loading states, optimistic UI)

### Hydration Directives (Best Practices from 10x-rules)
- `client:visible` - **Hydrate when visible in viewport** (use for below-fold components)
- `client:idle` - Hydrate when main thread is idle (default for most islands)
- `client:load` - Hydrate immediately on page load (use sparingly for critical components)
- `client:only="react"` - No SSR, client-only render (avoid if possible)
- `client:media` - Hydrate only at specific breakpoints (responsive hydration)
- **Use shared state with nanostores** instead of prop drilling between islands
- **Use content collections** for type-safe content management of structured content
- **Implement partial hydration strategies** to minimize JavaScript sent to the client
- **Use Astro's transition:* directives** for view transitions between pages
- **Leverage props** for passing data from Astro to framework components

**Example:**
```astro
---
import ChatInput from '../components/chat/ChatInput.tsx';
import HistoryList from '../components/history/HistoryList.tsx';
---

<!-- Critical: hydrate immediately -->
<ChatInput client:load />

<!-- Below fold: hydrate when visible -->
<HistoryList client:visible />
```

### React Component Best Practices

#### 1. Functional Components with Hooks
```tsx
import { useState, useCallback } from 'react';

export function ChatInput({ onSubmit }: { onSubmit: (text: string) => void }) {
  const [text, setText] = useState('');

  const handleSubmit = useCallback(() => {
    if (text.trim().length >= 10) {
      onSubmit(text);
      setText('');
    }
  }, [text, onSubmit]);

  return (
    <form onSubmit={handleSubmit}>
      {/* ... */}
    </form>
  );
}
```

#### 2. Never Use Next.js Directives
- **NO** `"use client"` (we're using Astro, not Next.js)
- **NO** `"use server"` (not applicable)

#### 3. Extract Logic into Custom Hooks
```tsx
// src/components/hooks/useAuth.ts
export function useAuth() {
  const [user, setUser] = useState(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Fetch user from Supabase
  }, []);

  return { user, isLoading };
}

// Usage in component
function UserMenu() {
  const { user, isLoading } = useAuth();
  // ...
}
```

#### 4. Performance Optimizations (Best Practices from 10x-rules)
```tsx
import { memo, useCallback, useMemo, lazy, Suspense } from 'react';

// Use React.memo() for expensive components that render often with the same props
export const ResponseCard = memo(({ response }: { response: Response }) => {
  // Component only re-renders if `response` changes
  return <div>{response.content}</div>;
});

// Use useCallback for event handlers passed to child components
function ChatContainer() {
  const handleRate = useCallback((responseId: number, rating: string) => {
    // This function won't be recreated on every render
  }, []);

  return <RatingButtons onRate={handleRate} />;
}

// Prefer useMemo for expensive calculations to avoid recomputation on every render
function QueryCard({ query }: { query: Query }) {
  const formattedDate = useMemo(() => {
    return new Intl.DateTimeFormat('pl-PL').format(new Date(query.created_at));
  }, [query.created_at]);

  return <time>{formattedDate}</time>;
}

// Utilize React.lazy() and Suspense for code-splitting and performance optimization
const HistoryList = lazy(() => import('./HistoryList'));

function HistoryView() {
  return (
    <Suspense fallback={<div>≈Åadowanie...</div>}>
      <HistoryList />
    </Suspense>
  );
}

// Use useTransition for non-urgent state updates to keep the UI responsive
import { useTransition } from 'react';

function SearchComponent() {
  const [isPending, startTransition] = useTransition();
  
  const handleSearch = (query: string) => {
    startTransition(() => {
      setSearchResults(filterResults(query));
    });
  };
}
```

#### 5. Use Suspense for Code Splitting
```tsx
import { lazy, Suspense } from 'react';

const HistoryList = lazy(() => import('./HistoryList'));

export function HistoryView() {
  return (
    <Suspense fallback={<div>≈Åadowanie...</div>}>
      <HistoryList />
    </Suspense>
  );
}
```

#### 6. Use useId() for Accessibility
```tsx
import { useId } from 'react';

export function InputField({ label }: { label: string }) {
  const id = useId(); // Generates unique ID

  return (
    <div>
      <label htmlFor={id}>{label}</label>
      <input id={id} />
    </div>
  );
}
```

#### 7. Optimistic UI with useOptimistic (React 19)
```tsx
import { useOptimistic } from 'react';

export function RatingButtons({ responseId, initialRating }: Props) {
  const [optimisticRating, setOptimisticRating] = useOptimistic(initialRating);

  async function handleRate(rating: 'up' | 'down') {
    // Update UI immediately
    setOptimisticRating(rating);

    // Send to server (might fail)
    await fetch(`/api/responses/${responseId}/ratings`, {
      method: 'POST',
      body: JSON.stringify({ rating })
    });
  }

  return (
    <div>
      <button onClick={() => handleRate('up')}>üëç</button>
      <button onClick={() => handleRate('down')}>üëé</button>
    </div>
  );
}
```

---

## Styling with Tailwind CSS (Best Practices from 10x-rules)

### Use Utility Classes
```tsx
<div className="max-w-4xl mx-auto p-6 bg-white rounded-lg shadow-md">
  <h2 className="text-2xl font-bold text-gray-900 mb-4">
    {title}
  </h2>
</div>
```

### Best Practices
- **Use the @layer directive** to organize styles into components, utilities, and base layers
- **Implement Just-in-Time (JIT) mode** for development efficiency and smaller CSS bundles
- **Use arbitrary values** with square brackets (e.g., `w-[123px]`) for precise one-off designs
- **Leverage the @apply directive** in component classes to reuse utility combinations
- **Implement the Tailwind configuration file** for customizing theme, plugins, and variants
- **Use component extraction** for repeated UI patterns instead of copying utility classes
- **Leverage the theme() function** in CSS for accessing Tailwind theme values
- **Implement dark mode** with the `dark:` variant
- **Use responsive variants** (sm:, md:, lg:, etc.) for adaptive designs
- **Leverage state variants** (hover:, focus:, active:, etc.) for interactive elements

### Conditional Classes with `cn()` Utility
```tsx
import { cn } from '@/lib/utils';

<button
  className={cn(
    "px-4 py-2 rounded-md font-medium",
    isActive && "bg-blue-600 text-white",
    !isActive && "bg-gray-200 text-gray-700"
  )}
>
  Click me
</button>
```

### Responsive Design
```tsx
<div className="flex flex-col md:flex-row gap-4">
  {/* Stacks vertically on mobile, horizontally on desktop */}
</div>
```

### Dark Mode (Prepare for Future)
```tsx
<div className="bg-white dark:bg-gray-900 text-gray-900 dark:text-white">
  {/* Automatically switches based on system preference */}
</div>
```

---

## Accessibility (WCAG AA)

### Semantic HTML
```tsx
// Good
<button onClick={handleClick}>Delete</button>
<nav><a href="/app">Dashboard</a></nav>

// Bad (never do this)
<div onClick={handleClick}>Delete</div>
<div><div onClick={goTo}>Dashboard</div></div>
```

### ARIA Attributes
```tsx
// For icon buttons without visible text
<button aria-label="Delete query" onClick={handleDelete}>
  <TrashIcon />
</button>

// For expandable content
<button
  aria-expanded={isOpen}
  aria-controls="dropdown-menu"
  onClick={toggle}
>
  User Menu
</button>

// For live regions (chat messages)
<div aria-live="polite" aria-atomic="true">
  {newMessage}
</div>
```

### Keyboard Navigation
```tsx
function Modal({ isOpen, onClose }: Props) {
  useEffect(() => {
    if (isOpen) {
      // Trap focus in modal
      const handleKeyDown = (e: KeyboardEvent) => {
        if (e.key === 'Escape') onClose();
      };
      document.addEventListener('keydown', handleKeyDown);
      return () => document.removeEventListener('keydown', handleKeyDown);
    }
  }, [isOpen, onClose]);

  return <dialog aria-modal="true">{/* ... */}</dialog>;
}
```

---

## API Integration

**IMPORTANT:** Frontend (Astro) is **deployment-agnostic** and connects to services via environment variables.

**Architecture:**
- Frontend (Astro) runs on port 4321 (configurable)
- Backend (FastAPI) URL configured via `PUBLIC_API_BASE_URL`
- Supabase URL configured via `PUBLIC_SUPABASE_URL`
- All URLs defined in `.env` file (see `.env.example` for deployment scenarios)

### Environment Variables

**Example for all-in-one deployment:**
```bash
# .env (Frontend - Astro)
PUBLIC_API_BASE_URL=http://localhost:8000
PUBLIC_SUPABASE_URL=http://localhost:8444
PUBLIC_SUPABASE_ANON_KEY=your-anon-key-here
```

**Example for distributed deployment:**
```bash
# .env (Frontend - Astro)
PUBLIC_API_BASE_URL=http://localhost:8000        # Backend on same machine
PUBLIC_SUPABASE_URL=http://192.168.0.11:8444     # Supabase on remote server
PUBLIC_SUPABASE_ANON_KEY=your-anon-key-here
```

**Example for cloud deployment:**
```bash
# .env (Frontend - Astro)
PUBLIC_API_BASE_URL=https://api.your-domain.com
PUBLIC_SUPABASE_URL=https://your-project.supabase.co
PUBLIC_SUPABASE_ANON_KEY=your-anon-key-here
```

### Use Fetch with Error Handling
```tsx
// Get API base URL from environment (defaults to localhost:8000)
const API_BASE_URL = import.meta.env.PUBLIC_API_BASE_URL || 'http://localhost:8000';

async function fetchQuery(queryId: number) {
  try {
    const response = await fetch(`${API_BASE_URL}/queries/${queryId}`, {
      headers: {
        'Authorization': `Bearer ${getToken()}`,
        'Content-Type': 'application/json'
      }
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Failed to fetch query:', error);
    throw error; // Re-throw for component to handle
  }
}
```

### Loading States
```tsx
function ChatInput() {
  const [isSubmitting, setIsSubmitting] = useState(false);

  async function handleSubmit(text: string) {
    setIsSubmitting(true);
    try {
      await fetch('/api/queries', { method: 'POST', body: JSON.stringify({ question: text }) });
    } finally {
      setIsSubmitting(false);
    }
  }

  return (
    <button disabled={isSubmitting}>
      {isSubmitting ? 'Wysy≈Çanie...' : 'Wy≈õlij'}
    </button>
  );
}
```

---

## TypeScript Best Practices

### Define Prop Types
```tsx
interface ResponseCardProps {
  response: {
    id: number;
    content: string;
    sources: Array<{ act_title: string; article: string; link: string }>;
    model_name: string;
    generation_time_ms: number;
  };
  onRate?: (rating: 'up' | 'down') => void;
}

export function ResponseCard({ response, onRate }: ResponseCardProps) {
  // ...
}
```

### Use Shared Types
```ts
// src/lib/types.ts
export interface Query {
  id: number;
  question: string;
  created_at: string;
  responses: Response[];
}

export interface Response {
  id: number;
  response_type: 'fast' | 'detailed';
  content: string;
  sources: Source[];
  model_name: string;
  generation_time_ms: number;
}

// Import in components
import type { Query, Response } from '@/lib/types';
```

---

## Testing (Vitest)

### Test React Components
```tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import { ChatInput } from './ChatInput';

describe('ChatInput', () => {
  it('calls onSubmit when text is valid', async () => {
    const onSubmit = vi.fn();
    render(<ChatInput onSubmit={onSubmit} />);

    const input = screen.getByRole('textbox');
    const button = screen.getByRole('button', { name: /wy≈õlij/i });

    fireEvent.change(input, { target: { value: 'Valid question text' } });
    fireEvent.click(button);

    expect(onSubmit).toHaveBeenCalledWith('Valid question text');
  });

  it('disables submit when text is too short', () => {
    render(<ChatInput onSubmit={vi.fn()} />);

    const input = screen.getByRole('textbox');
    const button = screen.getByRole('button');

    fireEvent.change(input, { target: { value: 'Short' } });

    expect(button).toBeDisabled();
  });
});
```

---

## Common Pitfalls to Avoid

1. **Don't use Astro components for interactivity** - Use React islands instead
2. **Don't hydrate everything** - Only interactive parts need client-side JS
3. **Don't forget client: directives** - React components won't work without them
4. **Don't use large libraries** - Keep bundle size small (<50KB)
5. **Don't skip accessibility** - Always add aria-labels and keyboard nav
6. **Don't hardcode API URLs** - Use environment variables
7. **Don't forget error boundaries** - Wrap React islands in error boundaries

---

## Shadcn/ui Integration

### Install Components
```bash
npx shadcn-ui@latest add button input textarea card alert
```

### Use in React Components
```tsx
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';

export function LoginForm() {
  return (
    <form>
      <Input type="email" placeholder="Email" />
      <Input type="password" placeholder="Has≈Ço" />
      <Button type="submit">Zaloguj</Button>
    </form>
  );
}
```

---

## Performance Checklist

- [ ] Static content uses Astro components (no React)
- [ ] React islands use appropriate `client:*` directive
- [ ] Expensive components wrapped in `memo()`
- [ ] Event handlers use `useCallback()`
- [ ] Heavy calculations use `useMemo()`
- [ ] Large components use `lazy()` + `Suspense`
- [ ] Images optimized with Astro `<Image />` component
- [ ] Bundle size checked (should be <50KB for main)
