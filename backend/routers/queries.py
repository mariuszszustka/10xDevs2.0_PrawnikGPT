"""
PrawnikGPT Backend - Query Management Endpoints

API endpoints for query management:
- POST /api/v1/queries - Submit new query
- GET /api/v1/queries - List queries (with pagination)
- GET /api/v1/queries/{query_id} - Get query details
- POST /api/v1/queries/{query_id}/accurate-response - Request accurate response
- DELETE /api/v1/queries/{query_id} - Delete query

All endpoints require authentication (JWT token).
"""

import logging
from typing import Optional
from fastapi import APIRouter, Depends, HTTPException, status, BackgroundTasks
from fastapi.responses import Response

from backend.models.query import (
    QuerySubmitRequest,
    QuerySubmitResponse,
    QueryDetailResponse,
    QueryListResponse,
    QueryListItem,
    QueryListItemFastResponse,
    QueryListItemAccurateResponse,
    AccurateResponseSubmitResponse,
    FastResponseDetail,
    AccurateResponseDetail,
    RatingDetail,
    PaginationMetadata,
    QueryProcessingStatus
)
from backend.models.error import ApiErrorCode, create_error_response
from backend.middleware.auth import get_current_user
from backend.middleware.rate_limit import check_rate_limit
from backend.services.rag_pipeline import (
    process_query_fast_background,
    process_query_accurate_background
)
from backend.db.queries import (
    get_query_by_id,
    list_queries,
    delete_query
)
from backend.db.ratings import get_ratings_by_query

logger = logging.getLogger(__name__)

# Create router
router = APIRouter(
    prefix="/api/v1/queries",
    tags=["queries"],
    dependencies=[Depends(check_rate_limit)]  # Apply rate limiting to all endpoints
)


# =========================================================================
# POST /api/v1/queries - Submit New Query
# =========================================================================

@router.post(
    "",
    response_model=QuerySubmitResponse,
    status_code=status.HTTP_202_ACCEPTED,
    summary="Submit new legal query",
    description="""
    Submit a new legal question for processing.
    
    The query is processed asynchronously:
    1. Query created immediately (returns 202 Accepted)
    2. Fast response generated in background (<15s)
    3. Results stored in database
    4. Client can poll GET /api/v1/queries/{query_id} for results
    
    Rate limits:
    - 10 queries per minute (authenticated users)
    
    Processing:
    - Fast response: <15 seconds (target)
    - Uses small model (mistral:7b)
    - Accurate response available via separate endpoint
    """,
    responses={
        202: {"description": "Query accepted for processing"},
        400: {"description": "Invalid query text (10-1000 chars required)"},
        401: {"description": "Unauthorized (invalid/missing token)"},
        429: {"description": "Rate limit exceeded"},
        503: {"description": "Service unavailable (OLLAMA or database down)"}
    }
)
async def submit_query(
    request: QuerySubmitRequest,
    background_tasks: BackgroundTasks,
    user_id: str = Depends(get_current_user)
):
    """
    Submit new legal query for processing.
    
    Args:
        request: Query submission request (query_text)
        background_tasks: FastAPI background tasks
        user_id: Authenticated user ID (from JWT)
        
    Returns:
        QuerySubmitResponse: Query acceptance response (202)
    """
    try:
        # Log query submission
        logger.info(
            f"Query submitted by user {user_id}: {request.query_text[:50]}..."
        )
        
        # Add background task for RAG pipeline
        background_tasks.add_task(
            process_query_fast_background,
            user_id=user_id,
            query_text=request.query_text
        )
        
        # Return immediate response (202 Accepted)
        # Note: query_id will be generated by background task
        # For now, return processing status
        return QuerySubmitResponse(
            query_id="processing",  # Will be assigned in background
            query_text=request.query_text,
            status="processing",
            created_at=None,  # Will be set in background
            fast_response={
                "status": "processing",
                "estimated_time_seconds": 15
            }
        )
        
    except Exception as e:
        logger.error(f"Failed to submit query: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Failed to submit query. Please try again."
        )


# =========================================================================
# GET /api/v1/queries - List Queries
# =========================================================================

@router.get(
    "",
    response_model=QueryListResponse,
    summary="List user queries",
    description="""
    Get paginated list of user's queries (history).
    
    Queries are ordered by creation date (newest first by default).
    Each query includes fast response summary and accurate response status.
    
    Pagination:
    - Default: page=1, per_page=20
    - Max per_page: 100
    
    Ordering:
    - desc: Newest first (default)
    - asc: Oldest first
    """,
    responses={
        200: {"description": "Query list retrieved successfully"},
        401: {"description": "Unauthorized"},
        422: {"description": "Invalid pagination parameters"}
    }
)
async def get_queries(
    page: int = 1,
    per_page: int = 20,
    order: str = "desc",
    user_id: str = Depends(get_current_user)
):
    """
    Get paginated list of user's queries.
    
    Args:
        page: Page number (1-indexed)
        per_page: Items per page (1-100)
        order: Sort order ("desc" or "asc")
        user_id: Authenticated user ID
        
    Returns:
        QueryListResponse: Paginated list of queries
    """
    try:
        # Validation
        if page < 1:
            raise HTTPException(
                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
                detail="Page must be >= 1"
            )
        if not (1 <= per_page <= 100):
            raise HTTPException(
                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
                detail="Per page must be 1-100"
            )
        if order not in ("desc", "asc"):
            raise HTTPException(
                status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
                detail="Order must be 'desc' or 'asc'"
            )
        
        # Fetch queries from database
        queries, total_count = await list_queries(
            user_id=user_id,
            page=page,
            per_page=per_page,
            order=order
        )
        
        # Calculate pagination metadata
        total_pages = (total_count + per_page - 1) // per_page
        
        pagination = PaginationMetadata(
            page=page,
            per_page=per_page,
            total_pages=total_pages,
            total_count=total_count
        )
        
        # Transform to QueryListItem format
        query_items = []
        for q in queries:
            # Build fast response summary
            fast_response = QueryListItemFastResponse(
                content=q.get("fast_response_content", "")[:200] + "..." if q.get("fast_response_content") and len(q.get("fast_response_content", "")) > 200 else q.get("fast_response_content", ""),
                model_name=q.get("fast_model_name", "unknown"),
                generation_time_ms=q.get("fast_generation_time_ms", 0),
                sources_count=len(q.get("sources", []) if q.get("sources") else []),
                rating=None  # Will be populated if rating exists
            )
            
            # Build accurate response summary (if exists)
            accurate_response = None
            if q.get("accurate_response_content"):
                accurate_response = QueryListItemAccurateResponse(
                    exists=True,
                    model_name=q.get("accurate_model_name"),
                    generation_time_ms=q.get("accurate_generation_time_ms"),
                    rating=None
                )
            
            query_items.append(QueryListItem(
                query_id=q["id"],
                query_text=q["query_text"],
                created_at=q["created_at"],
                fast_response=fast_response,
                accurate_response=accurate_response
            ))
        
        logger.info(
            f"Listed {len(query_items)} queries for user {user_id} "
            f"(page {page}, total {total_count})"
        )
        
        return QueryListResponse(
            queries=query_items,
            pagination=pagination
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to list queries: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve queries"
        )


# =========================================================================
# GET /api/v1/queries/{query_id} - Get Query Details
# =========================================================================

@router.get(
    "/{query_id}",
    response_model=QueryDetailResponse,
    summary="Get query details",
    description="""
    Get full details of a specific query including all responses and ratings.
    
    Returns:
    - Query text and metadata
    - Fast response (if completed)
    - Accurate response (if requested and completed)
    - Ratings for each response
    - Source references
    
    The query must belong to the authenticated user (RLS enforced).
    """,
    responses={
        200: {"description": "Query details retrieved"},
        401: {"description": "Unauthorized"},
        404: {"description": "Query not found or access denied"}
    }
)
async def get_query(
    query_id: str,
    user_id: str = Depends(get_current_user)
):
    """
    Get detailed information about a specific query.
    
    Args:
        query_id: Query ID (UUID)
        user_id: Authenticated user ID
        
    Returns:
        QueryDetailResponse: Full query details
    """
    try:
        # Fetch query from database (with RLS check)
        query = await get_query_by_id(query_id, user_id)
        
        if not query:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Query not found"
            )
        
        # Fetch ratings for this query
        ratings_data = await get_ratings_by_query(query_id, user_id)
        
        # Build ratings map (response_type -> RatingDetail)
        ratings_map = {}
        for r in ratings_data:
            ratings_map[r["response_type"]] = RatingDetail(
                value=r["rating_value"],  # Map db column to model field
                rating_id=r["id"],
                created_at=r["created_at"]
            )
        
        # Determine fast response status from content
        fast_status = "completed" if query.get("fast_response_content") else "pending"
        
        # Parse sources from JSONB
        sources_data = query.get("sources")
        sources_list = None
        if sources_data:
            if isinstance(sources_data, list):
                sources_list = sources_data
            elif isinstance(sources_data, str):
                import json
                try:
                    sources_list = json.loads(sources_data)
                except json.JSONDecodeError:
                    sources_list = None
        
        # Build fast response detail
        fast_response = FastResponseDetail(
            status=fast_status,
            content=query.get("fast_response_content"),
            model_name=query.get("fast_model_name"),
            generation_time_ms=query.get("fast_generation_time_ms"),
            sources=sources_list,
            rating=ratings_map.get("fast")
        )
        
        # Determine accurate response status from content
        accurate_status = "completed" if query.get("accurate_response_content") else None
        
        # Build accurate response detail (if exists)
        accurate_response = None
        if accurate_status:
            accurate_response = AccurateResponseDetail(
                status=accurate_status,
                content=query.get("accurate_response_content"),
                model_name=query.get("accurate_model_name"),
                generation_time_ms=query.get("accurate_generation_time_ms"),
                sources=sources_list,  # Reuse same sources
                rating=ratings_map.get("accurate")
            )
        
        # Determine overall status
        overall_status = fast_status
        
        # Build response
        response = QueryDetailResponse(
            query_id=query_id,
            query_text=query["query_text"],
            status=overall_status,
            created_at=query["created_at"],
            fast_response=fast_response,
            accurate_response=accurate_response
        )
        
        logger.info(f"Retrieved query {query_id} for user {user_id}")
        
        return response
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get query {query_id}: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve query"
        )


# =========================================================================
# POST /api/v1/queries/{query_id}/accurate-response - Request Accurate
# =========================================================================

@router.post(
    "/{query_id}/accurate-response",
    response_model=AccurateResponseSubmitResponse,
    status_code=status.HTTP_202_ACCEPTED,
    summary="Request accurate response",
    description="""
    Request detailed/accurate response for an existing query.
    
    Requirements:
    - Fast response must be completed first
    - Uses larger model (gpt-oss:120b)
    - Processing time: up to 240 seconds
    - Reuses cached context from fast response (if available)
    
    The accurate response is generated asynchronously:
    1. Request accepted immediately (returns 202)
    2. Response generated in background (<240s)
    3. Client can poll GET /api/v1/queries/{query_id} for results
    
    Rate limits:
    - 10 requests per minute (authenticated users)
    """,
    responses={
        202: {"description": "Accurate response request accepted"},
        401: {"description": "Unauthorized"},
        404: {"description": "Query not found"},
        409: {"description": "Accurate response already exists"},
        429: {"description": "Rate limit exceeded"}
    }
)
async def request_accurate_response(
    query_id: str,
    background_tasks: BackgroundTasks,
    user_id: str = Depends(get_current_user)
):
    """
    Request accurate/detailed response for existing query.
    
    Args:
        query_id: Query ID (UUID)
        background_tasks: FastAPI background tasks
        user_id: Authenticated user ID
        
    Returns:
        AccurateResponseSubmitResponse: Request acceptance (202)
    """
    try:
        # Check if query exists and belongs to user
        query = await get_query_by_id(query_id, user_id)
        
        if not query:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Query not found"
            )
        
        # Check if accurate response already exists
        if query.get("accurate_response_content"):
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="Accurate response already exists for this query"
            )
        
        # Check if fast response is completed
        if not query.get("fast_response_content"):
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="Fast response must be completed before requesting accurate response"
            )
        
        # Add background task for accurate response generation
        query_text = query.get("query_text", "")
        
        background_tasks.add_task(
            process_query_accurate_background,
            query_id=query_id,
            query_text=query_text
        )
        
        logger.info(
            f"Accurate response requested for query {query_id} by user {user_id}"
        )
        
        # Return immediate response (202 Accepted)
        return AccurateResponseSubmitResponse(
            query_id=query_id,
            accurate_response={
                "status": "processing",
                "estimated_time_seconds": 180  # ~3 minutes estimate
            }
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to request accurate response: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to request accurate response"
        )


# =========================================================================
# DELETE /api/v1/queries/{query_id} - Delete Query
# =========================================================================

@router.delete(
    "/{query_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete query",
    description="""
    Delete a query from history.
    
    This operation:
    - Deletes the query and all associated data
    - Cascades to ratings (if any)
    - Cannot be undone
    - Requires query ownership (RLS enforced)
    
    Returns 204 No Content on success.
    """,
    responses={
        204: {"description": "Query deleted successfully"},
        401: {"description": "Unauthorized"},
        404: {"description": "Query not found or access denied"}
    }
)
async def delete_query_endpoint(
    query_id: str,
    user_id: str = Depends(get_current_user)
):
    """
    Delete query from history.
    
    Args:
        query_id: Query ID (UUID)
        user_id: Authenticated user ID
        
    Returns:
        204 No Content
    """
    try:
        # Delete query (with RLS check)
        deleted = await delete_query(query_id, user_id)
        
        if not deleted:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Query not found"
            )
        
        logger.info(f"Deleted query {query_id} for user {user_id}")
        
        # Return 204 No Content
        return Response(status_code=status.HTTP_204_NO_CONTENT)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to delete query {query_id}: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete query"
        )

